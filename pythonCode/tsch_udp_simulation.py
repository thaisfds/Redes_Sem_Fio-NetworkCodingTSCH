import time
import threading
import random
from collections import deque
from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Union
import re
import sys
import os
import csv
import functools

# --- Adicionando bibliotecas para visualização e animação ---
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
# -----------------------------------------------------------

# Lista global para armazenar os eventos da simulação para a animação
simulation_events = []
simulation_events_lock = threading.Lock()


# Classe para redirecionar a saída APENAS para o arquivo
class DuplicarSaida:
    def __init__(self, stdout_original_nao_usado, file):
        self.file = file

    def write(self, data):
        self.file.write(data)
        self.file.flush()

    def flush(self):
        self.file.flush()


class NodeState(Enum):
    IDLE = "idle"
    TRANSMITTING = "transmitting"
    RECEIVING = "receiving"


@dataclass
class Message:
    id: int # Local ID for the message generated by a node
    source: int
    destination: Union[int, List[int]] # Can be an int (unicast) or a list of ints (multicast)
    data: str
    timestamp: float
    hop_count: int = 0
    path: List[int] = field(default_factory=list)
    # Added fields to align with NC version, but not used in non-NC simulation logic
    is_nc_coded: bool = False
    original_message_ids: List[int] = field(default_factory=list) # Global IDs if split
    nc_intended_destinations: List[int] = field(default_factory=list)
    is_nc_precursor: bool = False
    nc_precursor_original_final_dest: Optional[Union[int, List[int]]] = None
    global_id: Optional[int] = None # Global ID for the original message


class TSCHSlot:
    def __init__(self, slot_id: int, channel: int, tx_node: int, rx_node: int):
        self.slot_id = slot_id
        self.channel = channel
        self.tx_node = tx_node
        self.rx_node = rx_node


class TSCHSchedule:
    def __init__(self, slotframe_length: int = 2):
        self.slotframe_length = slotframe_length
        self.slots: List[TSCHSlot] = []
        self.current_slot = 0

    def add_slot(self, slot: TSCHSlot):
        self.slots.append(slot)

    def get_current_slot(self) -> Optional[TSCHSlot]:
        if self.slots:
            return self.slots[self.current_slot % len(self.slots)]
        return None

    def advance_slot(self):
        self.current_slot = (self.current_slot + 1) % len(self.slots) if self.slots else 0


class TSCHNode:
    def __init__(self, node_id: int, neighbors: List[int]):
        self.node_id = node_id
        self.neighbors = set(neighbors)
        self.state = NodeState.IDLE
        self.message_queue = deque()
        self.received_messages = []
        self.schedule = TSCHSchedule()
        self.network = None
        self.message_counter = 0 # Local message counter for this node
        self.lock = threading.Lock()
        self.transmitted_messages_by_channel: Dict[int, int] = {}
        # NC buffer is not used in this non-NC simulation, but kept for structural similarity
        self.nc_buffer: Dict[int, Message] = {}


    def set_network(self, network):
        self.network = network

    def add_neighbor(self, neighbor_id: int):
        self.neighbors.add(neighbor_id)

    def send_message(self, destination: Union[int, List[int]], data: str, global_id: int):
        with self.lock:
            self.message_counter += 1

            message = Message(
                id=self.message_counter, # Local message ID
                source=self.node_id,
                destination=destination, # Original final destination(s)
                data=data,
                timestamp=time.time(),
                path=[self.node_id], # Source node is the first in the path
                hop_count=0, # Start hop count at 0, it's incremented when a node RECEIVES it.
                global_id=global_id
            )

            self.network.total_messages_initiated += 1

            print(f"\n--- Node {self.node_id} - Sending Message ---")
            print(f"  Message ID (local): {message.id}")
            print(f"  Global Message ID: {message.global_id}")
            print(f"  Source: {self.node_id}")
            print(f"  Original Final Destination(s): {message.destination}") # Log original final destinations
            print(f"  Data: '{message.data}'")
            print(f"  Current Path (after source added): {message.path}")
            print(f"  Current Hop Count: {message.hop_count}")


            # Determine immediate next physical hop towards ANY of the final destinations
            next_physical_hop = None
            if isinstance(destination, list):
                # Try to find a neighbor that is one of the final destinations
                for dest_id in destination:
                    if dest_id in self.neighbors:
                        next_physical_hop = dest_id
                        break
                # If no direct neighbor is a final destination, find a next hop towards any of them
                if not next_physical_hop:
                    for dest_id in destination:
                        calculated_next_hop = self.get_next_hop(dest_id)
                        if calculated_next_hop:
                            next_physical_hop = calculated_next_hop
                            break # Pick the first viable next hop
            elif isinstance(destination, int):
                next_physical_hop = self.get_next_hop(destination)


            if next_physical_hop:
                print(f"  Transmitting to next physical hop: {next_physical_hop}.")
                with simulation_events_lock:
                    simulation_events.append((time.time(), message.global_id, self.node_id, next_physical_hop, "sending_regular"))

                # Deliver the message to the next physical hop.
                self.network.deliver_message(message, next_physical_hop)

                # Increment the transmission count for the initial send
                current_slot = self.schedule.get_current_slot()
                if current_slot:
                    self.transmitted_messages_by_channel[current_slot.channel] = \
                        self.transmitted_messages_by_channel.get(current_slot.channel, 0) + 1
            else:
                print(f"  ERROR: No route to any destination {message.destination} from node {self.node_id}.")
                self.network.messages_not_sent_no_route += 1
            print("-----------------------------------\n")

    def _send_retransmitted_message(self, message_to_retransmit: Message, next_physical_hop: int):
        """
        Helper method for intermediate nodes to retransmit a message.
        Increments channel transmission count but not total_messages_initiated.
        """
        # Note: message_to_retransmit.path and .hop_count should already be updated by receive_message
        
        # Add animation event for this retransmission
        with simulation_events_lock:
            simulation_events.append((time.time(), message_to_retransmit.global_id, self.node_id, next_physical_hop, "forwarding"))
        
        # Deliver the message to the next physical hop
        self.network.deliver_message(message_to_retransmit, next_physical_hop)

        # Increment the channel-specific transmission count for this retransmission
        current_slot = self.schedule.get_current_slot()
        if current_slot:
            self.transmitted_messages_by_channel[current_slot.channel] = \
                self.transmitted_messages_by_channel.get(current_slot.channel, 0) + 1

    def get_next_hop(self, destination: int) -> Optional[int]:
        """
        Determines the single next hop towards a given destination.
        Prefers direct neighbor if it's the destination or if it's a neighbor of the destination.
        """
        if destination in self.neighbors:
            return destination

        # Simple greedy approach: find a neighbor that is a neighbor of the destination
        for neighbor in self.neighbors:
            if self.network and neighbor in self.network.nodes:
                neighbor_node = self.network.nodes[neighbor]
                if destination in neighbor_node.neighbors:
                    return neighbor

        # Fallback: if no better route, pick any random neighbor.
        # This might lead to suboptimal paths but ensures a hop if possible.
        return list(self.neighbors)[0] if self.neighbors else None


    def receive_message(self, message: Message):
        with self.lock:
            print(f"\n--- Node {self.node_id} - Receiving Message ---")
            print(f"  Message ID (local source): {message.id}")
            print(f"  Global Message ID: {message.global_id}")
            print(f"  Source: {message.source}")
            print(f"  Original Final Destination(s): {message.destination}") # Original list/int
            print(f"  Data: '{message.data}'")
            print(f"  Current Path (before processing): {message.path}")
            print(f"  Current Hop Count (before processing): {message.hop_count}")

            # Add current node to path and increment hop count *upon receiving*
            if self.node_id not in message.path: # Avoid adding self multiple times if message loops
                message.path.append(self.node_id)
                message.hop_count += 1 # Increment hop count for this physical hop

            # Check if this node is one of the original final destinations
            is_final_destination_for_this_node = False
            if isinstance(message.destination, list):
                if self.node_id in message.destination:
                    is_final_destination_for_this_node = True
            elif self.node_id == message.destination: # Unicast case
                is_final_destination_for_this_node = True

            if is_final_destination_for_this_node:
                self.received_messages.append(message) # Store the message
                with simulation_events_lock:
                    last_hop_node = message.path[-2] if len(message.path) >= 2 else message.source
                    simulation_events.append((time.time(), message.global_id, last_hop_node, self.node_id, "received_final"))
                print(f"  SUCCESS: Node {self.node_id} received final message: '{message.data}'")
                print(f"  Final Path: {message.path}")
                print(f"  Final Hop Count: {message.hop_count}")
            
            # Determine if further forwarding is needed for other original destinations
            needs_forwarding = False
            forwarding_targets = [] # Which original destinations still need to be reached from this node

            if isinstance(message.destination, list):
                for original_final_dest_id in message.destination:
                    # If this original final destination hasn't been reached yet and is not the current node
                    if original_final_dest_id != self.node_id and original_final_dest_id not in message.path:
                        needs_forwarding = True
                        forwarding_targets.append(original_final_dest_id)
            elif not is_final_destination_for_this_node: # Unicast, and this is an intermediate node
                needs_forwarding = True
                forwarding_targets.append(message.destination) # The single final destination

            if needs_forwarding and message.hop_count < 5: # Global hop limit (already incremented by this receive)
                print(f"  Node {self.node_id} (intermediate) is forwarding message {message.id} (Global ID: {message.global_id}).")
                
                # For each target this node needs to forward to:
                for target_final_dest in forwarding_targets:
                    next_hop_for_this_target = self.get_next_hop(target_final_dest)

                    # Ensure next_hop is valid and not sending back to the immediate previous sender
                    # `message.path[-2]` is the previous node in the path, preventing immediate back-and-forth.
                    is_valid_forward = False
                    if next_hop_for_this_target:
                        if len(message.path) < 2: # If path only has source, any next_hop is valid (not sending back to source)
                            is_valid_forward = True
                        elif next_hop_for_this_target != message.path[-2]: # Ensure not sending back to last hop
                            is_valid_forward = True
                        # Additionally, prevent cycles by checking if next_hop_for_this_target is already in the path for this branch
                        if next_hop_for_this_target in message.path:
                             is_valid_forward = False # Avoid sending to a node already visited in this path
                             print(f"  WARNING: Skipping forward to {next_hop_for_this_target} as it's already in the path {message.path}. Avoiding cycle.")

                    if is_valid_forward:
                        # total_forwarded_messages counts the *logical* re-routing attempts
                        self.network.total_forwarded_messages += 1
                        
                        # Clone the message for EACH physical transmission FROM THIS NODE.
                        # This cloned message will effectively be a new "transmission" initiated by this node.
                        cloned_message_for_transmission = Message(
                            id=message.id, # Keep original local ID from source
                            source=message.source,
                            destination=message.destination, # Original final destination(s) for the next hop's routing
                            data=message.data,
                            timestamp=time.time(), # New timestamp for this retransmission
                            hop_count=message.hop_count, # Use current hop count (already incremented by receive for THIS node)
                            path=list(message.path), # Copy current path (already includes this node)
                            global_id=message.global_id
                        )

                        # CRITICAL CHANGE: Call THIS NODE's helper retransmission method
                        print(f"    - Initiating retransmission from {self.node_id} to {next_hop_for_this_target} for Global ID: {cloned_message_for_transmission.global_id} towards final dest {target_final_dest}. Current Path: {cloned_message_for_transmission.path}")
                        
                        self._send_retransmitted_message(cloned_message_for_transmission, next_hop_for_this_target)
                        
                    else:
                        print(f"  WARNING: Cannot forward message {message.id} (Global ID: {message.global_id}) towards {target_final_dest}. No suitable next_hop found or message returning to previous node/cycle detected.")
                        self.network.messages_dropped_no_forward_path += 1
            elif needs_forwarding and message.hop_count >= 5:
                 print(f"  WARNING: Message {message.id} (Global ID: {message.global_id}) dropped due to hop limit ({message.hop_count}).")
                 self.network.messages_dropped_hop_limit += 1
            
            # If not a final destination and no forwarding occurred (e.g., all destinations reached, or no route)
            elif not is_final_destination_for_this_node and not needs_forwarding:
                print(f"  Node {self.node_id} received message {message.id} (Global ID: {message.global_id}) but is not a final destination and no further forwarding path found/needed.")
            
            print("-------------------------------------\n")


    def process_tsch_slot(self):
        current_slot = self.schedule.get_current_slot()
        if current_slot:
            if current_slot.tx_node == self.node_id:
                self.state = NodeState.TRANSMITTING
            elif current_slot.rx_node == self.node_id:
                self.state = NodeState.RECEIVING
            else:
                self.state = NodeState.IDLE

        self.schedule.advance_slot()


class TSCHNetwork:
    def __init__(self):
        self.nodes: Dict[int, TSCHNode] = {}
        self.running = False
        self.slot_duration = 0.1
        self.topology_data = {}
        self.simulation_commands = []
        self.num_nodes_config = 0
        self.num_messages_config = 0
        self.available_channels = list(range(10))
        # NC-related variables (will remain unused but present for structural similarity)
        self.network_coding_enabled: Optional[int] = 0
        self.nc_coder_node_id: Optional[int] = None
        self.nc_senders_nodes_list: List[int] = []
        self.total_nc_coded_messages_sent = 0
        self.messages_dropped_not_intended_nc_dest = 0 # This metric is only relevant for NC

        # Common metrics
        self.total_messages_initiated = 0
        self.total_forwarded_messages = 0
        self.messages_not_sent_no_route = 0
        self.messages_dropped_hop_limit = 0
        self.messages_dropped_no_forward_path = 0

        self.original_message_data_map: Dict[int, Dict] = {} # To store original message details by global ID

    def add_node(self, node: TSCHNode):
        self.nodes[node.node_id] = node
        node.set_network(self)

    def parse_config_file(self, filename: str):
        """
        Lê e parseia o arquivo de configuração.
        Sempre pula as duas primeiras linhas (reservadas para Network Coding).
        Suporta múltiplos destinos na mesma linha para comandos de mensagem.
        """
        try:
            with open(filename, 'r') as f:
                lines = [line.strip() for line in f if line.strip() and not line.startswith('#')]

                if len(lines) < 3: # Need at least 3 lines: 2 skipped + num_nodes_config
                    print(f"ERROR: Configuration file '{filename}' has insufficient lines. Expected at least 3 (2 skipped + node config).")
                    sys.exit(1)

                # --- Skip the first two lines, as per requirement for non-NC simulation ---
                lines = lines[2:]
                # --------------------------------------------------------------------------

                self.num_nodes_config = int(lines[0])
                current_line_idx = 1
                self.topology_data = {}
                for i in range(self.num_nodes_config):
                    parts = [int(p) for p in lines[current_line_idx + i].split()]
                    node_id = parts[0]
                    neighbors = parts[1:]
                    self.topology_data[node_id] = neighbors
                current_line_idx += self.num_nodes_config

                num_command_lines = int(lines[current_line_idx]) # This is now the actual number of commands
                current_line_idx += 1

                self.simulation_commands = []
                self.original_message_data_map = {} # Important for animation and consistency

                global_message_id_counter = 0

                # Regex to match: source (int), destinations (space-separated ints, optional), [data in brackets]
                message_line_pattern = re.compile(r'(\d+)\s+((?:\d+\s+)*)\[(.*?)\]')

                for i in range(num_command_lines):
                    line = lines[current_line_idx + i]

                    match = message_line_pattern.match(line.strip())

                    if match:
                        source_str = match.group(1)
                        destinations_str = match.group(2).strip()
                        data = match.group(3)

                        source = int(source_str)
                        destinations = [int(d) for d in destinations_str.split()] if destinations_str else []

                        if not destinations:
                            print(f"WARNING: Line '{line}' has no specified destinations. Ignoring this command.")
                            continue

                        global_message_id_counter += 1 # Assign global ID

                        cmd = {
                            "type": "send",
                            "source": source,
                            "destination": destinations,
                            "data": data,
                            "global_id": global_message_id_counter
                        }
                        self.simulation_commands.append(cmd)
                        self.original_message_data_map[global_message_id_counter] = {
                            'data': data,
                            'destination': destinations
                        }
                    elif line.strip().lower().startswith("wait"):
                        wait_time_match = re.match(r'wait\s+(\d+\.?\d*)', line.strip().lower())
                        if wait_time_match:
                            wait_time = float(wait_time_match.group(1))
                            self.simulation_commands.append({"type": "wait", "time": wait_time})
                        else:
                            print(f"WARNING: Could not parse wait command from line: '{line}'")
                    else:
                        print(f"WARNING: Could not parse command from line: '{line}' - Invalid format or unknown command type. This line will be ignored.")

                self.num_messages_config = global_message_id_counter # Actual number of original messages to send

                if not any(cmd["type"] == "wait" for cmd in self.simulation_commands):
                     self.simulation_commands.append({"type": "wait", "time": 2.0}) # Add a default wait at the end

        except FileNotFoundError:
            print(f"ERROR: Configuration file '{filename}' not found.")
            print("Please ensure the file exists and the path is correct.")
            sys.exit(1)
        except Exception as e:
            print(f"ERROR: Error parsing configuration file '{filename}': {e}")
            sys.exit(1)

    def create_topology(self):
        """
        Cria a topologia com base nos dados lidos do arquivo de configuração.
        """
        if not self.topology_data:
            print("ERROR: Topology data not loaded. Please call parse_config_file first.")
            sys.exit(1)

        for node_id, neighbors in self.topology_data.items():
            node = TSCHNode(node_id, neighbors)
            self.add_node(node)

        self.setup_tsch_schedule() # Call to the method within the same class

    def setup_tsch_schedule(self):
        num_available_channels = len(self.available_channels)
        if num_available_channels == 0:
            print("WARNING: No channels available. All transmissions will use channel 0 (default fallback).")
            num_available_channels = 1
            self.available_channels = [0]


        for node_id, node in self.nodes.items():
            slot_id_counter = 0
            for neighbor in node.neighbors:
                assigned_channel_tx = self.available_channels[(slot_id_counter + node_id) % num_available_channels]
                assigned_channel_rx = self.available_channels[(slot_id_counter + neighbor) % num_available_channels]

                tx_slot = TSCHSlot(slot_id_counter, assigned_channel_tx, node_id, neighbor)
                node.schedule.add_slot(tx_slot)

                rx_slot = TSCHSlot(slot_id_counter + 1, assigned_channel_rx, neighbor, node_id)
                node.schedule.add_slot(rx_slot)

                slot_id_counter += 2

    def deliver_message(self, message: Message, target_node_id: int): # target_node_id is always an int now
        """
        Delivers a message to a single specified target node.
        """
        if target_node_id in self.nodes:
            threading.Thread(
                target=self._delayed_delivery,
                args=(message, target_node_id), # Pass the message directly
                daemon=True
            ).start()
        else:
            print(f"WARNING: Attempted to deliver message {message.id} (Global ID: {message.global_id}) to non-existent node {target_node_id}. Dropping.")


    def _delayed_delivery(self, message: Message, destination: int):
        time.sleep(random.uniform(0.01, 0.05))
        self.nodes[destination].receive_message(message)

    def start_tsch_timer(self):
        def tsch_timer():
            while self.running:
                for node in self.nodes.values():
                    node.process_tsch_slot()
                time.sleep(self.slot_duration)

        self.running = True
        threading.Thread(target=tsch_timer, daemon=True).start()

    def stop(self):
        self.running = False

    def run_simulation(self, output_base_path: str, output_file_base_name: str, results_csv_file_obj):
        global simulation_events
        simulation_events = []

        print("=" * 60)
        print("        INICIANDO SIMULAÇÃO TSCH + UDP")
        print(f"        Topologia da Rede: Carregada de '{output_file_base_name}.txt'")
        print(f"        Canais Disponíveis: {len(self.available_channels)}")
        print("        TODAS AS MENSAGENS ENVIADAS SIMULTANEAMENTE NO INÍCIO!")
        print("=" * 60)

        self.start_tsch_timer()

        time.sleep(0.5)

        # Process simulation commands as read from the file
        for command in self.simulation_commands:
            if command["type"] == "send":
                source_node = self.nodes.get(command["source"])
                if source_node:
                    source_node.send_message(
                        command["destination"], # This can now be a list
                        command["data"],
                        global_id=command["global_id"] # Pass the global ID
                    )
                else:
                    print(f"WARNING: Source node {command['source']} not found for sending message (Global ID: {command['global_id']}).")
            elif command["type"] == "wait":
                print(f"\n--- Waiting for {command['time']} seconds ---")
                time.sleep(command["time"])

        print("\n" + "=" * 60)
        print("        SIMULAÇÃO CONCLUÍDA")
        print("        Resumo de Mensagens Recebidas:")
        print("=" * 60)

        total_paths_found = 0
        received_global_ids_at_final_destinations = set() # Track unique global IDs that reached ANY of their final destination(s)

        for node_id, node in self.nodes.items():
            print(f"\nNó {node_id}:")
            if node.received_messages:
                num_received_by_this_node = 0
                for msg in node.received_messages:
                    # Check if this message was truly intended for this node as a final destination
                    # For cloned messages, message.destination is already an int for this specific branch
                    if node_id == msg.destination:
                        num_received_by_this_node += 1
                        received_global_ids_at_final_destinations.add(msg.global_id) # Add global ID to set if it reached a final dest

                print(f"  Total de mensagens recebidas (como destino final): {num_received_by_this_node}")
                for i, msg in enumerate(node.received_messages):
                    path_str = " -> ".join(map(str, msg.path))
                    display_dest = ""
                    # For a cloned message at final reception, message.destination is an int
                    display_dest = str(msg.destination)

                    print(f"    - Mensagem {i+1} (ID local: {msg.id}, Global ID: {msg.global_id}, Origem: {msg.source}, Destino Final: {display_dest}, Hops: {msg.hop_count}, Caminho: {path_str}): '{msg.data}'")
            else:
                print("  Nenhuma mensagem recebida.")

        total_paths_found = len(received_global_ids_at_final_destinations) # Count unique global messages delivered to at least one intended final destination

        print("\n--- Informações Adicionais da Simulação TSCH ---")
        slotframe_length = self.nodes[list(self.nodes.keys())[0]].schedule.slotframe_length if self.nodes else "N/A"
        print(f"Tamanho do Slotframe: {slotframe_length}")

        total_transmissions_by_channel = {}
        for node_id, node in self.nodes.items():
            for channel, count in node.transmitted_messages_by_channel.items():
                total_transmissions_by_channel[channel] = \
                    total_transmissions_by_channel.get(channel, 0) + count

        print("\nNúmero de Mensagens Transmitidas por Canal (Agregado):")
        total_transmissions = sum(total_transmissions_by_channel.values())
        num_channels_used = len(total_transmissions_by_channel)

        if total_transmissions_by_channel:
            for channel, count in sorted(total_transmissions_by_channel.items()):
                print(f"  Canal {channel}: {count} transmissões")
        else:
            print("  Nenhuma transmissão registrada por canal.")
        print(f"Total de transmissões em todos os canais: {total_transmissions}")
        print(f"Número total de canais utilizados: {num_channels_used}")

        # --- Logs das Métricas ---
        print("\n--- Desempenho de Mensagens ---")
        print(f"Mensagens originadas (tentadas): {self.total_messages_initiated}")
        print(f"Mensagens entregues com sucesso (únicas por Global ID): {total_paths_found}")
        print(f"Mensagens não enviadas (sem rota inicial): {self.messages_not_sent_no_route}")
        print(f"Mensagens descartadas por limite de hops: {self.messages_dropped_hop_limit}")
        print(f"Mensagens descartadas (sem caminho para frente): {self.messages_dropped_no_forward_path}")
        print(f"Total de mensagens reencaminhadas (hops intermediários): {self.total_forwarded_messages}")
        # Metrics specific to NC (will be 0 or unused in non-NC simulation)
        print(f"Mensagens descartadas (não é destino NC pretendido): {self.messages_dropped_not_intended_nc_dest}")
        print(f"Total de mensagens NC codificadas enviadas pelo codificador: {self.total_nc_coded_messages_sent}")
        # -----------------------------------

        print("--------------------------------------------------\n")

        self.stop()
        print("\n" + "=" * 60)

        if results_csv_file_obj:
            results_csv_writer = csv.writer(results_csv_file_obj)
            row_data = [
                output_file_base_name,
                self.num_nodes_config,
                self.num_messages_config, # This is the number of original messages configured
                total_paths_found,       # Unique global IDs successfully delivered
                slotframe_length,
                total_transmissions,
                num_channels_used,
                self.network_coding_enabled, # Will be 0
                self.total_messages_initiated,
                self.messages_not_sent_no_route,
                self.messages_dropped_hop_limit,
                self.messages_dropped_no_forward_path,
                self.total_forwarded_messages
            ]
            results_csv_writer.writerow(row_data)
            print(f"Dados da simulação adicionados ao CSV: {row_data}")

        topology_image_path_final = os.path.join(output_base_path, f"{output_file_base_name}_topology_final.png")
        self.plot_network_topology(save_path=topology_image_path_final)
        print(f"Imagem da topologia final salva como '{output_file_base_name}_topology_final.png'.")

        gif_output_path = os.path.join(output_base_path, f"{output_file_base_name}_traffic.gif")
        print("Gerando animação da rede. Isso pode levar um tempo...")
        self.animate_network_traffic(save_path=gif_output_path)
        print(f"Animação concluída! O arquivo '{gif_output_path}' foi gerado.")

    def plot_network_topology(self, save_path: Optional[str] = None):
        """
        Desenha a topologia da rede usando NetworkX e Matplotlib.
        Se save_path for fornecido, salva a imagem em vez de exibi-la.
        Similar ao tsch_udp_nc_simulation, but without NC-specific coloring.
        """
        G = nx.Graph()

        for node_id, neighbors in self.topology_data.items():
            G.add_node(node_id)
            for neighbor_id in neighbors:
                if neighbor_id in self.topology_data:
                    if not G.has_edge(node_id, neighbor_id):
                        G.add_edge(node_id, neighbor_id)

        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(G, seed=42)

        node_colors = ['lightblue'] * len(G.nodes)
        node_sizes = [1000] * len(G.nodes)

        # No NC coder node specific coloring in this non-NC simulation
        # if self.nc_coder_node_id in G.nodes:
        #     node_colors[list(G.nodes).index(self.nc_coder_node_id)] = 'orange'
        #     node_sizes[list(G.nodes).index(self.nc_coder_node_id)] = 1500

        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=node_sizes)
        nx.draw_networkx_edges(G, pos, edge_color='gray', width=1.5)
        nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold')

        plt.title("Topologia da Rede TSCH Carregada", fontsize=16)
        plt.axis('off')

        if save_path:
            plt.savefig(save_path, bbox_inches='tight', dpi=300)
            plt.close()
        else:
            plt.show()

    def animate_network_traffic(self, save_path: Optional[str] = None):
        """
        Gera uma animação do tráfego de mensagens na rede com setas e salva em um arquivo GIF.
        Adapted from tsch_udp_nc_simulation for consistent animation style.
        """
        if not simulation_events:
            print("Nenhum evento de simulação para animar.")
            return

        G = nx.Graph()
        for node_id, neighbors in self.topology_data.items():
            G.add_node(node_id)
            for neighbor_id in neighbors:
                if neighbor_id in self.topology_data:
                    if not G.has_edge(node_id, neighbor_id):
                        G.add_edge(node_id, neighbor_id)

        pos = nx.spring_layout(G, seed=42)

        fig, ax = plt.subplots(figsize=(10, 8))

        node_colors_base = ['lightblue'] * len(G.nodes)
        node_sizes_base = [1000] * len(G.nodes)

        # No NC coder node specific coloring in this non-NC simulation
        # if self.nc_coder_node_id in G.nodes:
        #     node_colors_base[list(G.nodes).index(self.nc_coder_node_id)] = 'orange'
        #     node_sizes_base[list(G.nodes).index(self.nc_coder_node_id)] = 1500

        nx.draw_networkx_nodes(G, pos, ax=ax, node_color=node_colors_base, node_size=node_sizes_base)
        nx.draw_networkx_edges(G, pos, ax=ax, edge_color='gray', width=1.5)
        nx.draw_networkx_labels(G, pos, ax=ax, font_size=12, font_weight='bold')

        start_time = min(event[0] for event in simulation_events)
        # Event structure is (timestamp, msg_id, from_node, to_node, event_type, optional_data)
        # For non-NC, optional_data will usually be None or irrelevant
        normalized_events = sorted([(e[0] - start_time, e[1], e[2], e[3], e[4], e[5] if len(e) > 5 else None) for e in simulation_events])

        max_sim_time_covered = normalized_events[-1][0] if normalized_events else 0.1

        gif_speed_factor = 2.0

        total_animation_real_time = (max_sim_time_covered + 1.0) * gif_speed_factor

        fps_gif = 10

        total_frames = int(total_animation_real_time * fps_gif)

        arrow_visibility_duration_sim_time = 0.5

        def update(frame):
            ax.clear()

            node_colors_current = list(node_colors_base)
            node_sizes_current = list(node_sizes_base)

            nx.draw_networkx_nodes(G, pos, ax=ax, node_color=node_colors_current, node_size=node_sizes_current)
            nx.draw_networkx_edges(G, pos, ax=ax, edge_color='gray', width=1.5)
            nx.draw_networkx_labels(G, pos, ax=ax, font_size=12, font_weight='bold')

            current_sim_time = (frame / fps_gif) / gif_speed_factor

            active_events = []
            for event_time, msg_id, from_node, to_node_raw, event_type, optional_data in normalized_events:
                if current_sim_time >= event_time and (current_sim_time - event_time) < arrow_visibility_duration_sim_time:
                    active_events.append((msg_id, from_node, to_node_raw, event_type, optional_data))

            current_messages_info = []

            for anim_msg_id, from_node, to_node_raw, event_type, optional_data in active_events:
                if from_node in pos:
                    arrow_color = 'red' # Default color for non-NC messages

                    display_to_node_text = ""
                    # For animation purposes, to_node_raw should be an int (the actual next hop).
                    display_to_node_text = str(to_node_raw)

                    info_text = f"M{anim_msg_id}: {from_node}->{display_to_node_text}"

                    offset_magnitude = (anim_msg_id % 3 - 1) * 0.05

                    # Specific handling for received_final to color the node
                    if event_type == "received_final":
                        # No arrow needed, but change node color
                        try:
                            # 'to_node_raw' here is the final receiver node
                            dest_idx = list(G.nodes).index(to_node_raw)
                            node_colors_current[dest_idx] = 'gold' # Node turns gold when it receives a final message
                        except ValueError:
                            pass # Node not found in graph nodes
                        continue # Don't draw an arrow for a 'received_final' event

                    # Drawing the arrow for 'sending_regular' and 'forwarding'
                    if isinstance(to_node_raw, int) and to_node_raw in pos: # Ensure it's a single integer node
                        x1, y1 = pos[from_node]
                        x2, y2 = pos[to_node_raw]

                        dx = x2 - x1
                        dy = y2 - y1
                        len_vec = (dx**2 + dy**2)**0.5

                        x1_off = x1 - (dy / len_vec) * offset_magnitude if len_vec > 0 else x1
                        y1_off = y1 + (dx / len_vec) * offset_magnitude if len_vec > 0 else y1
                        x2_off = x2 - (dy / len_vec) * offset_magnitude if len_vec > 0 else x2
                        y2_off = y2 + (dx / len_vec) * offset_magnitude if len_vec > 0 else y2

                        ax.annotate(
                            '', xy=(x2_off, y2_off), xytext=(x1_off, y1_off),
                            arrowprops=dict(facecolor=arrow_color, edgecolor=arrow_color, shrink=0.05, width=2, headwidth=10, headlength=10),
                            xycoords='data', textcoords='data'
                        )
                        current_messages_info.append(info_text)
                    else:
                        print(f"WARNING: Animation skipped for event type {event_type} with invalid to_node_raw: {to_node_raw}")


            ax.set_title(f"Animação da Rede TSCH\nTempo: {current_sim_time:.2f}s\n" +
                         "Tráfego Ativo: " + ", ".join(current_messages_info[:3]) + ("..." if len(current_messages_info) > 3 else ""),
                         fontsize=14)
            return ax,


        ani = FuncAnimation(fig, update, frames=total_frames, interval=(1000/fps_gif), blit=False, repeat=False)

        plt.close(fig)

        if save_path:
            try:
                print(f"Salvando animação como GIF... (isso pode demorar)")
                writer_gif = plt.matplotlib.animation.PillowWriter(fps=fps_gif)
                ani.save(save_path, writer=writer_gif)
            except Exception as e:
                print(f"Erro ao salvar animação GIF para '{save_path}': {e}")
                print("Verifique se a biblioteca 'Pillow' está instalada (`pip install Pillow`).")
        else:
            print("Caminho para salvar o GIF não fornecido. Animação não salva.")


def main():
    if len(sys.argv) < 2:
        sys.stdout.write("Uso: python3 tsch_udp_simulation.py <caminho_para_arquivo_de_entrada>\n")
        sys.exit(1)

    input_filepath = sys.argv[1]

    log_dir = "logs"
    project_root = os.path.dirname(os.path.abspath(sys.argv[0]))
    output_base_path = os.path.join(project_root, log_dir)

    os.makedirs(output_base_path, exist_ok=True)

    input_filename_without_ext = os.path.splitext(os.path.basename(input_filepath))[0]

    log_filename = f"{input_filename_without_ext}_log.txt"
    log_filepath = os.path.join(output_base_path, log_filename)

    results_csv_filepath = os.path.join(output_base_path, "simulation_results.csv")

    original_stdout = sys.stdout

    results_csv_file = None

    try:
        file_exists = os.path.exists(results_csv_filepath)
        results_csv_file = open(results_csv_filepath, 'a', newline='')

        if not file_exists:
            csv.writer(results_csv_file).writerow([
                "Nome_Config_Arquivo",
                "Numero_de_Nos_Config",
                "Numero_de_Mensagens_Config",
                "Numero_de_Caminhos_Completos",
                "Tamanho_do_Slotframe",
                "Numero_de_Transmissoes_Totais",
                "Numero_de_Canais_Usados",
                "Network_Coding",
                "Mensagens_Iniciadas",
                "Mensagens_Nao_Enviadas_Sem_Rota",
                "Mensagens_Descartadas_Hop_Limit",
                "Mensagens_Descartadas_Sem_Prox_Caminho",
                "Total_Retransmissoes_Logicas"
            ])

        log_file = open(log_filepath, 'w')
        sys.stdout = log_file

        print(f"Data/Hora da Simulação: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())}\n")

        network = TSCHNetwork()
        network.parse_config_file(input_filepath)
        network.create_topology()
        network.run_simulation(output_base_path, input_filename_without_ext, results_csv_file)

    except Exception as e:
        original_stdout.write(f"\nFATAL ERROR during simulation: {e}\n")
        import traceback
        original_stdout.write(traceback.format_exc())
        sys.exit(1)
    finally:
        sys.stdout = original_stdout
        if 'log_file' in locals() and not log_file.closed:
            log_file.close()
        if results_csv_file and not results_csv_file.closed:
            results_csv_file.close()

        print(f"Registro de log concluído! O arquivo '{log_filename}' foi gerado.")
        print(f"Dados da simulação adicionados a 'simulation_results.csv'.")
        print(f"Verifique o diretório '{output_base_path}'.")


if __name__ == "__main__":
    main()